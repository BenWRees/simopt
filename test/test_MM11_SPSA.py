import unittest
import math

from simopt.experiment_base import ProblemSolver, post_normalize

# Note: Tests have inherent randomness and may vary **slightly** between
#       runs/systems. To make sure these tsts still work, assertAlmostEqual
#       is used instead of assertEqual.
#       Some attributes, such as the lengths of lists, are still checked
#       with assertEqual as these should not change between runs.

class test_MM11_SPSA(unittest.TestCase):
    def setUp(self):
        # Expected values
        self.expected_problem_name = "MM1-1"
        self.expected_solver_name = "SPSA"
        self.expected_all_recommended_xs = "[[(5,), (4.9,), (4.828220242877966,), (4.7711583208381505,), (4.723356247271821,), (4.68199124553989,), (4.645378954588569,), (4.612444103015851,), (4.582458610463401,), (4.554898657638183,), (4.529364764236633,), (4.505556753022127,), (4.483237995267522,), (4.462218240075169,), (4.4423416198344805,), (4.4423416198344805,)], [(5,), (4.9,), (4.828268158857998,), (4.77125483623946,), (4.723516406221871,), (4.682219351774141,), (4.645691726023226,), (4.612860645066556,), (4.582980956756656,), (4.555521245546239,), (4.530091984205564,), (4.506399094048835,), (4.484204055878755,), (4.463313252399071,), (4.44356775526693,), (4.44356775526693,)], [(5,), (4.9,), (4.82823275038073,), (4.77117250564012,), (4.723397826999347,), (4.68205529632045,), (4.645470553365282,), (4.612599470427855,), (4.582700704662216,), (4.555214194443706,), (4.529748789482907,), (4.506008016885367,), (4.483762945089936,), (4.462827836579088,), (4.443047831595067,), (4.443047831595067,)], [(5,), (4.9,), (4.82829756612476,), (4.771339855695114,), (4.723662803100289,), (4.682430559303078,), (4.645982100052345,), (4.613221916775132,), (4.5834046662460315,), (4.5560079333949774,), (4.530632771098154,), (4.506973585550738,), (4.484800768623456,), (4.4639247852540995,), (4.444193643993295,), (4.444193643993295,)], [(5,), (4.9,), (4.828242201209379,), (4.77124633252754,), (4.72354459954432,), (4.682284832130805,), (4.645777394471522,), (4.6129551554667785,), (4.583085669022961,), (4.555644025130443,), (4.530235421844773,), (4.506549316233128,), (4.484344301558645,), (4.463436572342113,), (4.443680365996481,), (4.443680365996481,)], [(5,), (4.9,), (4.828231076513505,), (4.7711855092155036,), (4.723394504996676,), (4.682031945761324,), (4.645431670927897,), (4.612525516390906,), (4.582584649842427,), (4.5550807905705515,), (4.529610075601041,), (4.505863936314328,), (4.48360278121546,), (4.462634686662727,), (4.442809303376692,), (4.442809303376692,)], [(5,), (4.9,), (4.828219519984448,), (4.771140758673957,), (4.723326734506081,), (4.681939665803399,), (4.645321340494433,), (4.61239575863478,), (4.582426092470732,), (4.554874501548695,), (4.529352338311446,), (4.505558750506955,), (4.483254550686463,), (4.462247367333755,), (4.442377777121177,), (4.442377777121177,)], [(5,), (4.9,), (4.828155661607367,), (4.771043245392106,), (4.723177248151974,), (4.681738456913554,), (4.645066791335422,), (4.612087630607207,), (4.58207093833194,), (4.554481682758663,), (4.528920891992599,), (4.505093949146714,), (4.482765194735492,), (4.461742626586988,), (4.441866368917596,), (4.441866368917596,)], [(5,), (4.9,), (4.828281141238866,), (4.771301910273989,), (4.7235850644093755,), (4.682297832549166,), (4.645788402306378,), (4.612970315545531,), (4.583087744250104,), (4.555636424495865,), (4.530221829011507,), (4.50652503564759,), (4.484315641542501,), (4.463404679389659,), (4.443634821147833,), (4.443634821147833,)], [(5,), (4.9,), (4.828246904978977,), (4.7711933083053015,), (4.72336757968074,), (4.681961154914754,), (4.645321235876414,), (4.612375186030644,), (4.5824035533924885,), (4.5548737532009484,), (4.529374807930149,), (4.505599879463623,), (4.483311991698891,), (4.462319081864509,), (4.4424676346064285,), (4.4424676346064285,)]]"
        self.expected_all_intermediate_budgets = "[[0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000]]"
        self.expected_all_est_objectives = "[[2.7852321578182706, 2.6946279475220236, 2.6311375353093958, 2.5815909136385455, 2.5407237828666345, 2.505841251941293, 2.4753383640165523, 2.4482028810050203, 2.423744531241904, 2.401474586372536, 2.381022748133891, 2.3621138063084017, 2.344526730196806, 2.3280879148376177, 2.3126552972698806, 2.3126552972698806], [2.7857037031168543, 2.695126537700335, 2.63168194454411, 2.5821814252519157, 2.541376437373668, 2.5065523009671264, 2.476119059122977, 2.4490652673952376, 2.4246952701571605, 2.402510211644764, 2.3821422375656103, 2.36332187487213, 2.3458294060330154, 2.329489039760201, 2.3141547052234297, 2.3141547052234297], [2.7866293625352507, 2.6961046932671304, 2.6326820691530157, 2.5831889418536957, 2.542409040822468, 2.5076066276640705, 2.477184488773275, 2.4501553002503287, 2.425825610132746, 2.4036715010325467, 2.3833349425035237, 2.364534830402029, 2.347062013649749, 2.330742520884411, 2.3154374476605555, 2.3154374476605555], [2.7889080044387127, 2.6984477573213246, 2.635135828933808, 2.585775437901453, 2.54509781446391, 2.510395608353966, 2.4800918861536076, 2.4531499186231587, 2.4288814940969723, 2.406794740252417, 2.3865245574018488, 2.3677937136480938, 2.3503799896464534, 2.3341097150698054, 2.3188431071073454, 2.3188431071073454], [2.7833651638972787, 2.692599781727439, 2.629004094601332, 2.5794164287265913, 2.5385477333860207, 2.50367268131143, 2.473184727194505, 2.4460715118093446, 2.421644803109403, 2.3994126371985356, 2.379007083755229, 2.3601407946557873, 2.342591322237028, 2.326194656663775, 2.3108117589360293, 2.3108117589360293], [2.787955763524055, 2.6974232257205517, 2.6339966545686377, 2.584531643600397, 2.543736526240428, 2.508904663287842, 2.478455710249972, 2.4513849491432467, 2.4270097098749273, 2.404832813497743, 2.384479226847435, 2.3656653877957323, 2.3481693007493503, 2.3318143314711266, 2.3164656772875185, 2.3164656772875185], [2.7843462630059106, 2.6937443851097407, 2.6302528723982768, 2.580691384896225, 2.5398194950870128, 2.5049162090353296, 2.4744062850681607, 2.447278501046964, 2.4228353312890767, 2.4005765335493097, 2.3801373142152853, 2.3612437490432767, 2.3436757325094892, 2.3272531489548056, 2.311830552690829, 2.311830552690829], [2.7907221687784363, 2.7003710275094375, 2.6370425306039538, 2.5876457442612764, 2.5468936452724757, 2.512101923612372, 2.481692348994331, 2.454648510641304, 2.4302871385411304, 2.4081143503971427, 2.3877595588028, 2.368949226681737, 2.351469574584122, 2.335143543542223, 2.319825244786257, 2.319825244786257], [2.789502875694011, 2.698992211223711, 2.6356220111466024, 2.586200489101941, 2.5454473160694437, 2.510661975842597, 2.480277916983691, 2.4532669215479244, 2.428928192223854, 2.406779509623768, 2.3864578005189134, 2.3676673221475277, 2.3501918404481987, 2.333862225664954, 2.3185349953784105, 2.3185349953784105], [2.7891645344327056, 2.6987272929089374, 2.63539935834784, 2.5859999527459054, 2.5452368917962325, 2.510424903770189, 2.480002860981241, 2.452967966027958, 2.4286297089055737, 2.4064889712633875, 2.3861632089218143, 2.3673768084373803, 2.3499094991169045, 2.3335810179783176, 2.3182545152861813, 2.3182545152861813]]"
        self.expected_objective_curves = "[([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.6946279475220236, 2.6311375353093958, 2.5815909136385455, 2.5407237828666345, 2.505841251941293, 2.4753383640165523, 2.4482028810050203, 2.423744531241904, 2.401474586372536, 2.381022748133891, 2.3621138063084017, 2.344526730196806, 2.3280879148376177, 2.3126552972698806, 2.3126552972698806]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.695126537700335, 2.63168194454411, 2.5821814252519157, 2.541376437373668, 2.5065523009671264, 2.476119059122977, 2.4490652673952376, 2.4246952701571605, 2.402510211644764, 2.3821422375656103, 2.36332187487213, 2.3458294060330154, 2.329489039760201, 2.3141547052234297, 2.3141547052234297]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.6961046932671304, 2.6326820691530157, 2.5831889418536957, 2.542409040822468, 2.5076066276640705, 2.477184488773275, 2.4501553002503287, 2.425825610132746, 2.4036715010325467, 2.3833349425035237, 2.364534830402029, 2.347062013649749, 2.330742520884411, 2.3154374476605555, 2.3154374476605555]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.6984477573213246, 2.635135828933808, 2.585775437901453, 2.54509781446391, 2.510395608353966, 2.4800918861536076, 2.4531499186231587, 2.4288814940969723, 2.406794740252417, 2.3865245574018488, 2.3677937136480938, 2.3503799896464534, 2.3341097150698054, 2.3188431071073454, 2.3188431071073454]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.692599781727439, 2.629004094601332, 2.5794164287265913, 2.5385477333860207, 2.50367268131143, 2.473184727194505, 2.4460715118093446, 2.421644803109403, 2.3994126371985356, 2.379007083755229, 2.3601407946557873, 2.342591322237028, 2.326194656663775, 2.3142353892554004, 2.3142353892554004]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.6974232257205517, 2.6339966545686377, 2.584531643600397, 2.543736526240428, 2.508904663287842, 2.478455710249972, 2.4513849491432467, 2.4270097098749273, 2.404832813497743, 2.384479226847435, 2.3656653877957323, 2.3481693007493503, 2.3318143314711266, 2.3164656772875185, 2.3164656772875185]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.6937443851097407, 2.6302528723982768, 2.580691384896225, 2.5398194950870128, 2.5049162090353296, 2.4744062850681607, 2.447278501046964, 2.4228353312890767, 2.4005765335493097, 2.3801373142152853, 2.3612437490432767, 2.3436757325094892, 2.3272531489548056, 2.311830552690829, 2.311830552690829]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.7003710275094375, 2.6370425306039538, 2.5876457442612764, 2.5468936452724757, 2.512101923612372, 2.481692348994331, 2.454648510641304, 2.4302871385411304, 2.4081143503971427, 2.3877595588028, 2.368949226681737, 2.351469574584122, 2.335143543542223, 2.319825244786257, 2.319825244786257]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.698992211223711, 2.6356220111466024, 2.586200489101941, 2.5454473160694437, 2.510661975842597, 2.480277916983691, 2.4532669215479244, 2.428928192223854, 2.406779509623768, 2.3864578005189134, 2.3676673221475277, 2.3501918404481987, 2.333862225664954, 2.3185349953784105, 2.3185349953784105]), ([0, 210, 270, 330, 390, 450, 510, 570, 630, 690, 750, 810, 870, 930, 990, 1000], [2.7854035060729516, 2.6987272929089374, 2.63539935834784, 2.5859999527459054, 2.5452368917962325, 2.510424903770189, 2.480002860981241, 2.452967966027958, 2.4286297089055737, 2.4064889712633875, 2.3861632089218143, 2.3673768084373803, 2.3499094991169045, 2.3335810179783176, 2.3182545152861813, 2.3182545152861813])]"
        self.expected_progress_curves = "[([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8073393438332358, 0.6725882646611852, 0.5674312731280845, 0.48069550024102414, 0.40666135047522195, 0.34192248798433705, 0.28433055414378905, 0.23242052693669077, 0.18515513678298637, 0.14174846831657004, 0.10161641958371544, 0.06428987841113835, 0.029400388285570993, -0.0033535630470761164, -0.0033535630470761164]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8083975439968614, 0.6737437104888685, 0.5686845659386396, 0.48208068417800576, 0.40817047004518825, 0.3435794233298306, 0.2861608698197354, 0.23443836065956275, 0.18735313201072518, 0.14412445555288964, 0.10418040581412483, 0.06705465766871703, 0.032374114377325895, -0.00017124255460168242, -0.00017124255460168242]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8104735664013529, 0.6758663596521034, 0.5708229037544178, 0.4842722659339505, 0.41040815689052357, 0.3458406749134361, 0.2884743388686465, 0.2368373769241183, 0.18981783483405418, 0.1466558342590072, 0.10675476406674118, 0.06967072520966021, 0.03503448353107184, 0.002551230361838237, 0.002551230361838237]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.815446449689849, 0.681074181856555, 0.576312443380374, 0.4899788779594046, 0.41632744682196704, 0.35201129061632, 0.29483007107110704, 0.24332313828010121, 0.19644654995375638, 0.15342542410279567, 0.11367136799163466, 0.07671274668410807, 0.04218096493592079, 0.009779349848770129, 0.009779349848770129]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8030347957914807, 0.6680602827542734, 0.5628161796310084, 0.4760770861273705, 0.4020588093599393, 0.3373516421542035, 0.2798069687830652, 0.22796409608418916, 0.18077888741380624, 0.13747045308863712, 0.09742892984875437, 0.060182198178336394, 0.02538216611334411, 0.0, 0.0]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8132719995006195, 0.6786564156187533, 0.5736726333918357, 0.4870897006681304, 0.41316308783224076, 0.348538695919788, 0.29108412685944585, 0.2393504920945151, 0.19228258663653197, 0.14908444583748168, 0.10915424177618321, 0.07202081440304665, 0.037309277916470804, 0.004733529185256262, 0.004733529185256262]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8054640844921521, 0.6707106696382147, 0.5655221270924904, 0.4787762536974982, 0.4046980535692017, 0.3399442578895523, 0.2823686642682608, 0.23049085487193324, 0.1832491232154888, 0.13986923691910985, 0.09976982336026613, 0.06248373394392669, 0.027628693951815164, -0.005103988319104497, -0.005103988319104497]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8195283689018351, 0.6851209362995859, 0.5802819529737996, 0.4937903217826744, 0.41994890421159503, 0.35540808845470834, 0.2980106598347684, 0.24630645653527602, 0.19924727032855397, 0.1560465721747257, 0.11612381116934399, 0.0790252650799365, 0.0443751466632429, 0.011863823827071447, 0.011863823827071447]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8166019903195162, 0.682106047544069, 0.5772145655429667, 0.4907206548179378, 0.4168927811031373, 0.352406119602924, 0.2950783962879234, 0.24342224966988976, 0.1964142247006136, 0.1532837403161544, 0.11340311660522988, 0.07631342170531803, 0.04165569721084034, 0.009125418230866796, 0.009125418230866796]), ([0.0, 0.21, 0.27, 0.33, 0.39, 0.45, 0.51, 0.57, 0.63, 0.69, 0.75, 0.81, 0.87, 0.93, 0.99, 1.0], [1.0, 0.8160397317427623, 0.6816334926516318, 0.5767889502500856, 0.49027405356097553, 0.41638962296499843, 0.351822344953001, 0.2944438976678015, 0.24278875324339877, 0.1957975905311736, 0.15265850361913663, 0.11278653475306706, 0.07571418478495662, 0.04105886632055023, 0.008530131575811251, 0.008530131575811251])]"

        # Convert the expected values from string to their actual types
        self.expected_all_recommended_xs = eval(self.expected_all_recommended_xs, {'nan': float('nan'), 'inf': float('inf')})
        self.expected_all_intermediate_budgets = eval(self.expected_all_intermediate_budgets, {'nan': float('nan'), 'inf': float('inf')})
        self.expected_all_est_objectives = eval(self.expected_all_est_objectives, {'nan': float('nan'), 'inf': float('inf')})
        self.expected_objective_curves = eval(self.expected_objective_curves, {'nan': float('nan'), 'inf': float('inf')})
        self.expected_progress_curves = eval(self.expected_progress_curves, {'nan': float('nan'), 'inf': float('inf')})
        
        # Number of macro-replications and post-replications
        self.num_macroreps = 10
        self.num_postreps = 200

        # Setup the solver and experiment
        self.myexperiment = ProblemSolver(self.expected_solver_name, self.expected_problem_name)
        self.assertEqual(self.myexperiment.solver.name, self.expected_solver_name, "Solver name does not match (expected: " + self.expected_solver_name + ", actual: " + self.myexperiment.solver.name + ")")
        self.assertEqual(self.myexperiment.problem.name, self.expected_problem_name, "Problem name does not match (expected: " + self.expected_problem_name + ", actual: " + self.myexperiment.problem.name + ")")

    def test_run(self):
        # Check actual run results against expected
        self.myexperiment.run(n_macroreps=self.num_macroreps)
        self.assertEqual(self.myexperiment.n_macroreps, self.num_macroreps, "Number of macro-replications for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " does not match.")
        # For each macroreplication
        for mrep in range(self.num_macroreps):
            # Check to make sure the list lengths are the same
            self.assertEqual(len(self.myexperiment.all_recommended_xs[mrep]), len(self.expected_all_recommended_xs[mrep]), "Length of recommended solutions for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match.")
            # For each list of recommended solutions
            for list in range(len(self.myexperiment.all_recommended_xs[mrep])):
                # Check to make sure the tuples are the same length
                self.assertEqual(len(self.myexperiment.all_recommended_xs[mrep][list]), len(self.expected_all_recommended_xs[mrep][list]), "Recommended solutions for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(list) + ".")
                # For each tuple of recommended solutions
                for tuple in range(len(self.myexperiment.all_recommended_xs[mrep][list])):
                    self.assertAlmostEqual(self.myexperiment.all_recommended_xs[mrep][list][tuple], self.expected_all_recommended_xs[mrep][list][tuple], 5, "Recommended solutions for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(list) + " and tuple " + str(tuple) + ".")
            # Check to make sure the list lengths are the same
            self.assertEqual(len(self.myexperiment.all_intermediate_budgets[mrep]), len(self.expected_all_intermediate_budgets[mrep]), "Length of intermediate budgets for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match.")
            # For each list of intermediate budgets
            for list in range(len(self.myexperiment.all_intermediate_budgets[mrep])):
                # Check the values in the list
                self.assertAlmostEqual(self.myexperiment.all_intermediate_budgets[mrep][list], self.expected_all_intermediate_budgets[mrep][list], 5, "Intermediate budgets for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(list) + ".")
            
    def test_post_replicate(self):
        # Simulate results from the run method
        self.myexperiment = ProblemSolver(self.expected_solver_name, self.expected_problem_name)
        self.myexperiment.n_macroreps = self.num_macroreps
        self.myexperiment.all_recommended_xs = self.expected_all_recommended_xs
        self.myexperiment.all_intermediate_budgets = self.expected_all_intermediate_budgets

        # Check actual post-replication results against expected
        self.myexperiment.post_replicate(n_postreps=self.num_postreps)
        self.assertEqual(self.myexperiment.n_postreps, self.num_postreps, "Number of post-replications for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " does not match.")
        # For each macroreplication
        for mrep in range(self.num_macroreps):
            # Check to make sure the list lengths are the same
            self.assertEqual(len(self.myexperiment.all_est_objectives[mrep]), len(self.expected_all_est_objectives[mrep]), "Estimated objectives for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match.")
            # For each list in the estimated objectives
            for list in range(len(self.myexperiment.all_est_objectives[mrep])):
                # Check the values in the list
                self.assertAlmostEqual(self.myexperiment.all_est_objectives[mrep][list], self.expected_all_est_objectives[mrep][list], 5, "Estimated objectives for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(list) + ".")

    def test_post_normalize(self):
        # Simulate results from the post_replicate method
        self.myexperiment = ProblemSolver(self.expected_solver_name, self.expected_problem_name)
        self.myexperiment.n_macroreps = self.num_macroreps
        self.myexperiment.n_postreps = self.num_postreps
        self.myexperiment.all_recommended_xs = self.expected_all_recommended_xs
        self.myexperiment.all_intermediate_budgets = self.expected_all_intermediate_budgets
        self.myexperiment.all_est_objectives = self.expected_all_est_objectives

        # Check actual post-normalization results against expected
        post_normalize([self.myexperiment], n_postreps_init_opt=self.num_postreps)

        # Loop through each curve object and convert it into a tuple
        for i in range(len(self.myexperiment.objective_curves)):
            self.myexperiment.objective_curves[i] = (self.myexperiment.objective_curves[i].x_vals, self.myexperiment.objective_curves[i].y_vals)
        for i in range(len(self.myexperiment.progress_curves)):
            self.myexperiment.progress_curves[i] = (self.myexperiment.progress_curves[i].x_vals, self.myexperiment.progress_curves[i].y_vals)

        for mrep in range(self.num_macroreps):
            # Check to make sure the same number of objective curves are present
            # This should probably always be 2 (x and y)
            self.assertEqual(len(self.myexperiment.objective_curves[mrep]), len(self.expected_objective_curves[mrep]), "Number of objective curves for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " does not match.")
            # Make sure that curves are only checked if they exist
            if (len(self.myexperiment.objective_curves[mrep]) > 0):
                # Make sure the lengths of the X and Y values are the same
                self.assertEqual(len(self.myexperiment.objective_curves[mrep][0]), len(self.expected_objective_curves[mrep][0]), "Length of X values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match.")
                self.assertEqual(len(self.myexperiment.objective_curves[mrep][1]), len(self.expected_objective_curves[mrep][1]), "Length of Y values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match.")
                # Check X (0) and Y (1) values
                for x_index in range(len(self.myexperiment.objective_curves[mrep][0])):
                    # If the value is NaN, make sure we're expecting NaN
                    if (math.isnan(self.myexperiment.objective_curves[mrep][0][x_index])):
                        self.assertTrue(math.isnan(self.expected_objective_curves[mrep][0][x_index]), "X values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(x_index) + ".")
                    # Otherwise, check the value normally
                    else:
                        self.assertAlmostEqual(self.myexperiment.objective_curves[mrep][0][x_index], self.expected_objective_curves[mrep][0][x_index], 5, "X values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(x_index) + ".")
                for y_index in range(len(self.myexperiment.objective_curves[mrep][1])):
                    # If the value is NaN, make sure we're expecting NaN
                    if (math.isnan(self.myexperiment.objective_curves[mrep][1][y_index])):
                        self.assertTrue(math.isnan(self.expected_objective_curves[mrep][1][y_index]), "Y values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(y_index) + ".")
                    # Otherwise, check the value normally
                    else:
                        self.assertAlmostEqual(self.myexperiment.objective_curves[mrep][1][y_index], self.expected_objective_curves[mrep][1][y_index], 5, "Y values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(y_index) + ".")
            
            # Check to make sure the same number of progress curves are present
            # This should probably always be 2 (x and y)
            self.assertEqual(len(self.myexperiment.progress_curves[mrep]), len(self.expected_progress_curves[mrep]), "Number of progress curves for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " does not match.")
            # Make sure that curves are only checked if they exist
            if (len(self.myexperiment.progress_curves[mrep]) > 0):
                # Make sure the lengths of the X and Y values are the same
                self.assertEqual(len(self.myexperiment.progress_curves[mrep][0]), len(self.expected_progress_curves[mrep][0]), "Length of X values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match.")
                self.assertEqual(len(self.myexperiment.progress_curves[mrep][1]), len(self.expected_progress_curves[mrep][1]), "Length of Y values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match.")
                # Check X (0) and Y (1) values
                for x_index in range(len(self.myexperiment.progress_curves[mrep][0])):
                    # If the value is NaN, make sure we're expecting NaN
                    if (math.isnan(self.myexperiment.progress_curves[mrep][0][x_index])):
                        self.assertTrue(math.isnan(self.expected_progress_curves[mrep][0][x_index]), "X values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(x_index) + ".")
                    # Otherwise, check the value normally
                    else:
                        self.assertAlmostEqual(self.myexperiment.progress_curves[mrep][0][x_index], self.expected_progress_curves[mrep][0][x_index], 5, "X values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(x_index) + ".")
                for y_index in range(len(self.myexperiment.progress_curves[mrep][1])):
                    # If the value is NaN, make sure we're expecting NaN
                    if (math.isnan(self.myexperiment.progress_curves[mrep][1][y_index])):
                        self.assertTrue(math.isnan(self.expected_progress_curves[mrep][1][y_index]), "Y values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(y_index) + ".")
                    # Otherwise, check the value normally
                    else:
                        self.assertAlmostEqual(self.myexperiment.progress_curves[mrep][1][y_index], self.expected_progress_curves[mrep][1][y_index], 5, "Y values for problem " + self.expected_problem_name + " and solver " + self.expected_solver_name + " do not match at mrep " + str(mrep) + " and index " + str(y_index) + ".")      

:mod:`wrapper_base`
===================

.. py:module:: wrapper_base

.. autoapi-nested-parse::

   Summary
   -------
   Provide base classes for experiments and meta experiments.
   Plus helper functions for reading/writing data and plotting.

   Listing
   -------
   Experiment : class
   record_experiment_results : function
   read_experiment_results : function
   stylize_plot : function
   stylize_solvability_plot : function
   save_plot : function
   area_under_prog_curve : function
   solve_time_of_prog_curve : function
   MetaExperiment : class
   stylize_area_plot : function



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   wrapper_base.Experiment
   wrapper_base.MetaExperiment



Functions
~~~~~~~~~

.. autoapisummary::

   wrapper_base.trim_solver_results
   wrapper_base.record_experiment_results
   wrapper_base.read_experiment_results
   wrapper_base.stylize_plot
   wrapper_base.stylize_solvability_plot
   wrapper_base.save_plot
   wrapper_base.area_under_prog_curve
   wrapper_base.solve_time_of_prog_curve
   wrapper_base.stylize_area_plot



.. class:: Experiment(solver_name, problem_name, solver_fixed_factors={}, problem_fixed_factors={}, oracle_fixed_factors={})


   Bases: :py:obj:`object`

   Base class for running one solver on one problem.

   .. attribute:: solver

      simulation-optimization solver

      :type: base.Solver object

   .. attribute:: problem

      simulation-optimization problem

      :type: base.Problem object

   .. attribute:: n_macroreps

      number of macroreplications run

      :type: int > 0

   .. attribute:: crn_across_solns

      indicates if CRN are used when simulating different solutions

      :type: bool

   .. attribute:: all_recommended_xs

      sequences of recommended solutions from each macroreplication

      :type: list of lists of tuples

   .. attribute:: all_intermediate_budgets

      sequences of intermediate budgets from each macroreplication

      :type: list of lists

   .. attribute:: n_postreps

      number of postreplications to take at each recommended solution

      :type: int

   .. attribute:: n_postreps_init_opt

      number of postreplications to take at initial x0 and optimal x*

      :type: int

   .. attribute:: crn_across_budget

      use CRN for post-replications at solutions recommended at different times?

      :type: bool

   .. attribute:: crn_across_macroreps

      use CRN for post-replications at solutions recommended on different macroreplications?

      :type: bool

   .. attribute:: all_reevaluated_solns

      reevaluated solutions recommended by the solver

      :type: list of Solution objects

   .. attribute:: all_post_replicates

      all post-replicates from all solutions from all macroreplications

      :type: list of lists of lists

   .. attribute:: all_est_objective

      estimated objective values of all solutions from all macroreplications

      :type: numpy array of arrays

   .. attribute:: all_prog_curves

      estimated progress curves from all macroreplications

      :type: numpy array of arrays

   .. attribute:: initial_soln

      initial solution (w/ postreplicates) used for normalization

      :type: base.Solution object

   .. attribute:: ref_opt_soln

      reference optimal solution (w/ postreplicates) used for normalization

      :type: base.Solution object

   .. attribute:: areas

      areas under each estimated progress curve

      :type: list of floats

   .. attribute:: area_mean

      sample mean area under estimated progress curves

      :type: float

   .. attribute:: area_std_dev

      sample standard deviation of area under estimated progress curves

      :type: float

   .. attribute:: area_mean_CI

      bootstrap CI of the form [lower bound, upper bound] for mean area

      :type: numpy array of length 2

   .. attribute:: area_std_dev_CI

      bootstrap CI of the form [lower_bound, upper_bound] for std dev of area

      :type: numpy array of length 2

   .. attribute:: solve_tols

      relative optimality gap(s) definining when a problem is solved

      :type: list of floats in (0,1]

   .. attribute:: solve_times = list of lists of floats

      solve_tol solve times for each estimated progress curve for each solve_tol

   .. attribute:: solve_time_quantiles

      beta quantile of solve times for each solve_tole

      :type: list of floats

   .. attribute:: solve_time_quantiles_CIs

      bootstrap CI of the form [lower bound, upper bound] for quantile of solve time
      for each solve_tol

      :type: list of numpy arrays of length 2

   :param solver_name: name of solver
   :type solver_name: string
   :param problem_name: name of problem
   :type problem_name: string
   :param solver_fixed_factors: dictionary of user-specified solver factors
   :type solver_fixed_factors: dict
   :param problem_fixed_factors: dictionary of user-specified problem factors
   :type problem_fixed_factors: dict
   :param oracle_fixed_factors: dictionary of user-specified oracle factors
   :type oracle_fixed_factors: dict

   .. method:: run(self, n_macroreps, crn_across_solns)

      Run n_macroreps of the solver on the problem.

      :param n_macroreps: number of macroreplications of the solver to run on the problem
      :type n_macroreps: int
      :param crn_across_solns: indicates if CRN are used when simulating different solutions
      :type crn_across_solns: bool


   .. method:: post_replicate(self, n_postreps, n_postreps_init_opt, crn_across_budget=True, crn_across_macroreps=False)

      Run postreplications at solutions recommended by the solver.

      :param n_postreps: number of postreplications to take at each recommended solution
      :type n_postreps: int
      :param n_postreps_init_opt: number of postreplications to take at initial x0 and optimal x*
      :type n_postreps_init_opt: int
      :param crn_across_budget: use CRN for post-replications at solutions recommended at different times?
      :type crn_across_budget: bool
      :param crn_across_macroreps: use CRN for post-replications at solutions recommended on different macroreplications?
      :type crn_across_macroreps: bool


   .. method:: plot_progress_curves(self, plot_type, beta=0.5, normalize=True, plot_CIs=True)

      Produce plots of the solver's performance on the problem.

      :param plot_type:
                        indicates which type of plot to produce
                            "all" : all estimated progress curves
                            "mean" : estimated mean progress curve
                            "quantile" : estimated beta quantile progress curve
      :type plot_type: string
      :param beta: quantile to plot, e.g., beta quantile
      :type beta: float in (0,1)
      :param normalize: normalize progress curves w.r.t. optimality gaps?
      :type normalize: Boolean
      :param plot_CIs: plot bootstrapping confidence intervals?
      :type plot_CIs: Boolean


   .. method:: plot_solvability_curves(self, solve_tols=[0.1], plot_CIs=True)

      Plot the solvability curve(s) for a single solver-problem pair.
      Optionally plot bootstrap CIs.

      :param solve_tols: relative optimality gap(s) definining when a problem is solved
      :type solve_tols: list of floats in (0,1]
      :param plot_CIs: plot bootstrapping confidence intervals?
      :type plot_CIs: Boolean


   .. method:: compute_area_stats(self, compute_CIs=True)

      Compute average and standard deviation of areas under progress curves.
      Optionally compute bootstrap confidence intervals.

      :param compute_CIs: compute bootstrap confidence invervals for average and std dev?
      :type compute_CIs: Boolean


   .. method:: compute_solvability(self, solve_tols=[0.1])

      Compute alpha-solve times for all macroreplications.
      Can specify multiple values of alpha.

      :param solve_tols: relative optimality gap(s) definining when a problem is solved
      :type solve_tols: list of floats in (0,1]


   .. method:: compute_solvability_quantiles(self, beta=0.5, compute_CIs=True)

      Compute beta quantile of solve times, for each solve tolerance.
      Optionally compute bootstrap confidence intervals.

      :param beta: quantile to compute, e.g., beta quantile
      :type beta: float in (0,1)
      :param compute_CIs: compute bootstrap confidence invervals for quantile?
      :type compute_CIs: Boolean


   .. method:: bootstrap_sample(self, bootstrap_rng, crn_across_budget=True, crn_across_macroreps=False)

      Generate a bootstrap sample of estimated progress curves (normalized and unnormalized).

      :param bootstrap_rng: random number generator to use for bootstrapping
      :type bootstrap_rng: MRG32k3a object
      :param crn_across_budget: use CRN for resampling postreplicates at solutions recommended at different times?
      :type crn_across_budget: bool
      :param crn_across_macroreps: use CRN for resampling postreplicates at solutions recommended on different macroreplications?
      :type crn_across_macroreps: bool

      :returns: * **bootstrap_est_objective** (*numpy array of arrays*) -- bootstrapped estimated objective values of all solutions from all macroreplications
                * **bootstrap_prog_curves** (*numpy array of arrays*) -- bootstrapped estimated progress curves from all macroreplications


   .. method:: bootstrap_CI(self, plot_type, normalize, estimator, n_bootstraps=100, conf_level=0.95, bias_correction=True, beta=0.5, tol_index=0)

      Construct bootstrap confidence intervals and compute max half-width.

      :param plot_type:
                        indicates which type of plot to produce
                            "mean" : estimated mean progress curve
                            "quantile" : estimated beta quantile progress curve
                            "area_mean" : mean of area under convergence curve
                            "area_std_dev" : standard deviation of area under progress curve
                            "solve_time_quantile" : beta quantile of solve time
                            "solvability" : estimated solvability curve
      :type plot_type: string
      :param normalize: normalize progress curves w.r.t. optimality gaps?
      :type normalize: Boolean
      :param estimator: estimated mean or quantile progress curve
      :type estimator: numpy array
      :param n_bootstraps: number of times to generate a bootstrap sample of estimated progress curves
      :type n_bootstraps: int > 0
      :param conf_level: confidence level for confidence intervals, i.e., 1-alpha
      :type conf_level: float in (0,1)
      :param bias_correction: use bias-corrected bootstrap CIs (via percentile method)?
      :type bias_correction: bool
      :param beta: quantile for quantile aggregate progress curve, e.g., beta quantile
      :type beta: float in (0,1)
      :param tol_index: index of solve tolerance
      :type tol_index: int >= 0

      :returns: * **bs_CI_lower_bounds** (*numpy array*) -- lower bounds of bootstrap CIs at all budgets
                * **bs_CI_upper_bounds** (*numpy array*) -- upper bounds of bootstrap CIs at all budgets
                * **max_halfwidth** (*float*) -- maximum halfwidth of all bootstrap confidence intervals constructed


   .. method:: plot_bootstrap_CIs(self, plot_type, normalize, estimator, plot_CIs, beta=None, tol_index=None)

      Optionally plot bootstrap confidence intervals and report max
      half-width.

      :param plot_type:
                        indicates which type of plot to produce
                            "all" : all estimated progress curves
                            "mean" : estimated mean progress curve
                            "quantile" : estimated beta quantile progress curve
                            "solvability" : estimated solvability curve
      :type plot_type: string
      :param normalize: normalize progress curves w.r.t. optimality gaps?
      :type normalize: Boolean
      :param estimator: estimated mean or quantile progress curve
      :type estimator: numpy array
      :param plot_CIs: plot bootstrapping confidence intervals?
      :type plot_CIs: Boolean
      :param beta: quantile for quantile aggregate progress curve, e.g., beta quantile
      :type beta: float in (0,1) (optional)
      :param tol_index: index of solve tolerance
      :type tol_index: int >= 0


   .. method:: clear_runs(self)

      Delete results from run() method and any downstream results.


   .. method:: clear_postreps(self)

      Delete results from post_replicate() method and any downstream results.


   .. method:: clear_stats(self)

      Delete summary statistics associated with experiment.



.. function:: trim_solver_results(problem, recommended_solns, intermediate_budgets)

   Trim solutions recommended by solver after problem's max budget.

   :param problem: Problem object on which the solver was run
   :type problem: base.Problem object
   :param recommended_solutions: solutions recommended by the solver
   :type recommended_solutions: list of base.Solution objects
   :param intermediate_budgets: intermediate budgets at which solver recommended different solutions
   :type intermediate_budgets: list of ints >= 0


.. function:: record_experiment_results(experiment, file_name)

   Save wrapper_base.Experiment object to .pickle file.

   :param experiment: Experiment object to pickle
   :type experiment: wrapper_base.Experiment object
   :param file_name: base name of pickle file to write outputs to
   :type file_name: string


.. function:: read_experiment_results(file_name)

   Read in wrapper_base.Experiment object from .pickle file.

   :param file_name: base name of pickle file from which to read in outputs
   :type file_name: string

   :returns: **experiment** -- experiment that has been run or has been post-processed
   :rtype: wrapper_base.Experiment object


.. function:: stylize_plot(plot_type, solver_name, problem_name, normalize, budget=None, beta=None)

   Create new figure. Add labels to plot and reformat axes.

   :param plot_type:
                     indicates which type of plot to produce
                         "all" : all estimated progress curves
                         "mean" : estimated mean progress curve
                         "quantile" : estimated beta quantile progress curve
   :type plot_type: string
   :param solver_name: name of solver
   :type solver_name: string
   :param problem_name: name of problem
   :type problem_name: string
   :param normalize: normalize progress curves w.r.t. optimality gaps?
   :type normalize: Boolean
   :param budget: budget of problem, measured in function evaluations
   :type budget: int
   :param beta: quantile for quantile aggregate progress curve, e.g., beta quantile
   :type beta: float in (0,1) (optional)


.. function:: stylize_solvability_plot(solver_name, problem_name, solve_tol, plot_type, beta=0.5)

   Create new figure. Add labels to plot and reformat axes.

   :param solver_name: name of solver
   :type solver_name: string
   :param problem_name: name of problem
   :type problem_name: string
   :param solve_tol: relative optimality gap definining when a problem is solved
   :type solve_tol: float in (0,1]
   :param plot_type:
                     type of plot
                         - "single"
                         - "average"
                         - "profile"
   :type plot_type: string
   :param beta: quantile to compute, e.g., beta quantile
   :type beta: float in (0,1)


.. function:: save_plot(solver_name, problem_name, plot_type, normalize, extra)

   Create new figure. Add labels to plot and reformat axes.

   :param solver_name: name of solver
   :type solver_name: string
   :param problem_name: name of problem
   :type problem_name: string
   :param plot_type:
                     indicates which type of plot to produce
                         "all" : all estimated progress curves
                         "mean" : estimated mean progress curve
                         "quantile" : estimated beta quantile progress curve
                         "solvability" : estimated solvability curve
                         "area" : area scatterplot
   :type plot_type: string
   :param normalize: normalize progress curves w.r.t. optimality gaps?
   :type normalize: Boolean
   :param extra: extra number specifying quantile (e.g., beta) or solve tolerance
   :type extra: float


.. function:: area_under_prog_curve(prog_curve, frac_inter_budgets)

   Compute the area under a normalized estimated progress curve.

   :param prog_curve: normalized estimated progress curve for a macroreplication
   :type prog_curve: numpy array
   :param frac_inter_budgets: fractions of budget at which the progress curve is defined
   :type frac_inter_budgets: numpy array

   :returns: **area** -- area under the estimated progress curve
   :rtype: float


.. function:: solve_time_of_prog_curve(prog_curve, frac_inter_budgets, solve_tol)

   Compute the solve time of a normalized estimated progress curve.

   :param prog_curve: normalized estimated progress curves for a macroreplication
   :type prog_curve: numpy array
   :param frac_inter_budgets: fractions of budget at which the progress curve is defined
   :type frac_inter_budgets: numpy array
   :param solve_tol: relative optimality gap definining when a problem is solved
   :type solve_tol: float in (0,1]

   :returns: **solve_time** -- time at which the normalized progress curve first drops below
             solve_tol, i.e., the "alpha" solve time
   :rtype: float


.. class:: MetaExperiment(solver_names, problem_names, fixed_factors_filename=None)


   Bases: :py:obj:`object`

   Base class for running one or more solver on one or more problem.

   .. attribute:: solver_names

      list of solver names

      :type: list of strings

   .. attribute:: n_solvers

      number of solvers

      :type: int > 0

   .. attribute:: problem_names

      list of problem names

      :type: list of strings

   .. attribute:: n_problems

      number of problems

      :type: int > 0

   .. attribute:: all_solver_fixed_factors



      fixed solver factors for each solver
          outer key is solver name
          inner key is factor name

      :type: dict of dict

   .. attribute:: all_problem_fixed_factors



      fixed problem factors for each problem
          outer key is problem name
          inner key is factor name

      :type: dict of dict

   .. attribute:: all_oracle_fixed_factors



      fixed oracle factors for each problem
          outer key is problem name
          inner key is factor name

      :type: dict of dict

   .. attribute:: experiments

      all problem-solver pairs

      :type: list of list of Experiment objects

   :param solver_names: list of solver names
   :type solver_names: list of strings
   :param problem_names: list of problem names
   :type problem_names: list of strings
   :param fixed_factors_filename: name of .py file containing dictionaries of fixed factors
                                  for solvers/problems/oracles.
   :type fixed_factors_filename: string

   .. method:: run(self, n_macroreps=10, crn_across_solns=True)

      Run n_macroreps of each solver on each problem.

      :param n_macroreps: number of macroreplications of the solver to run on the problem
      :type n_macroreps: int
      :param crn_across_solns: indicates if CRN are used when simulating different solutions
      :type crn_across_solns: bool


   .. method:: post_replicate(self, n_postreps, n_postreps_init_opt, crn_across_budget=True, crn_across_macroreps=False)

      For each problem-solver pair, run postreplications at solutions
      recommended by the solver on each macroreplication.

      :param n_postreps: number of postreplications to take at each recommended solution
      :type n_postreps: int
      :param n_postreps_init_opt: number of postreplications to take at initial x0 and optimal x*
      :type n_postreps_init_opt: int
      :param crn_across_budget: use CRN for post-replications at solutions recommended at different times?
      :type crn_across_budget: bool
      :param crn_across_macroreps: use CRN for post-replications at solutions recommended on different macroreplications?
      :type crn_across_macroreps: bool


   .. method:: plot_area_scatterplot(self, plot_CIs=True, all_in_one=True)

      Plot a scatter plot of mean and standard deviation of area under progress curves.
      Either one plot for each solver or one plot for all solvers.


   .. method:: plot_solvability_profiles(self, solve_tol=0.1, beta=0.5)

      Plot the solvability profiles for each solver-problem pair.
      Two types of plots:
          1) average solvability curve
          2) solvability profile

      :param solve_tol: relative optimality gap definining when a problem is solved
      :type solve_tol: float in (0,1]
      :param beta: quantile to compute, e.g., beta quantile
      :type beta: float in (0,1)



.. function:: stylize_area_plot(solver_name)

   Create new figure for area plots. Add labels to plot and reformat axes.

   :param solver_name: name of solver
   :type solver_name: string


